---
title: quicli
categories:
- rust
---
I recently wrote a new Rust crate: [quicli].
Right now, quicli gives you a way of quickly writing CLI programs in Rust.
(Hence the name.)
In this short essay,
I want to present the ideas and underlaying philosophies
of this project.

[quicli]: https://github.com/killercup/quicli

## Some history

I've been writing CLI tools in Rust for a while now.
I published a post
["5 Tips for Writing Small CLI Tools in Rust"][cli-tips]
at the end of August 2017
that you may have read,
where I describes some of my take-aways from that
in the form of short tips.
Ever since then,
I wanted to condense this down into a small framework or library
but so far didn't find the time
to really sit down do this.
For some reason[^9e-talk],
after all these months,
I've now published a very early version.

[cli-tips]: {% post_url 2017-08-31-rust-cli-tips %}

[^9e-talk]: Okay, I admit, I promised to give a talk about Rust, and I wanted to present some nice, clean example code. (Of course, in the end I didn't show quicli in the talk.)

I was actually Sunday evening
when I published the code,
and I did so without thinking much about it.
But then something very interesting happened the very next day:
After a link to quicli's repo was posted to reddit,
Garrett Berg ([vitiral]) [replied] saying that
their [stdcli] project was very similar to my endeavor.
This was was unexpected.
And not only were out projects similar,
but we were both willing to join forces
and try to make one great crate
that takes the best of both approaches.
Garrett opened a few issues on [quicli's issue tracker][issues] (thanks!),
which basically concluded in [#19],
which was originally titled
"merge stdcli and this lib".

[vitiral]: https://github.com/vitiral
[replied]: https://www.reddit.com/r/rust/comments/7s3zsd/quicli_quickly_build_cool_cli_apps_in_rust/dt28i2b/
[stdcli]: https://github.com/vitiral/stdcli
[issues]: https://github.com/killercup/quicli/issues
[#19]: https://github.com/killercup/quicli/issues/19

That sounded pretty awesome and made me really proud:
Did me library
– which was barely a day old at this point –

But, before blindly agreeing to this,
I needed to take a step back
and evaluate what I want quicli to be.
Because, let's be honest,
I hadn't really thought about a 'grand quicli vision'
before.
And why should I?
I just wanted a small framework-like thing
that made writing CLI apps less of a pain.
But how exactly do I want to to this?
Thanks to Garretts' questions and comments
I now have an answer to this.

## What do I want to quicli to be

(The following are basically quotes from [#19].)

My goal is to provide
an opinionated set
of convenience functions
to quickly build CLI apps
– And I want to stop there!

In contrast to that,
[stdcli] exports a huge bunch of stuff.
As Garrett writes:

> stdcli's goal is basically to make creating a CLI in rust more like creating one in python from a user experience and ergonomics point of view.
> This means:
> batteries [are] included,
> almost everything you need is already imported […]


quicli also re-exports a bunch of stuff,
and I agree that these re-exports make the experience of writing CLIs quickly much more smooth.
There are some traits that are very useful, and deserve to re-exported!
I want to be very deliberate in what I re-export, though.
Let me give some reasoning for this.

First, a disclaimer:
I'm not sure what crates/functions/types/traits "typical Rust CLI apps" actually use
(I'd love to hear what people are actually using!).

For example:
Having Read and Write in the prelude seems like a good idea, but AtomicBool?
I've never used that one the last 4 years I've written Rust code.
Let's take a step back and think
and look at it from another perspective:
I'm pretty sure even Read and Write are only used in a few specific use cases.
I say: We should try to identify these use cases,
and provide convenience functions for those!

I didn't want to re-export `env_logger`;
instead I changed the `main!` macro
(that quicli provides to set give you nice error handling
and the ability to use `?` in your "main" function)
to initialize the logger automatically.
Similarly, I added simple file read/write functions.

Writing this, the following dawned on me:

I'd rather introduce some (simple and leaky) abstractions
(that promise to only be useful 80% of the time)
instead trying to give the user everything they need.

Another example (which I haven't implemented) that works this way:
A `regex_matches` function
that automatically uses `lazy_static` and only covers the simplest case
(maybe even return a very simple type
instead of a powerful iterator over capture results).
Why?
Simple: Have you seen the regex docs?
They are _wonderful._
Sadly, for newcomers/forgetful people/drunk programmers/etc.
they are also _wonderfully complex._

So, instead of offering the user "everything,"
I want to introduce some abstractions that are simple to use,
and have simple but useful examples.
Not not get stuck,
and to give user the ability to grow, learn, and discover new stuff,
the documentation should point exactly to where to look
when you want to use some of the features on a more complex level.

Indeed, instead of adding any feature flags to this crate
(that enable additional components to be loaded/exposed),
I want to have a clear line
where a user is supposed to stop relying on quicli.
I'd rather have an "eject" option
to switch from quicli to "all crates imported manually"
than add and re-export a whole bunch crates
(which will at some point lead to `extern crate kitchensink;`).
